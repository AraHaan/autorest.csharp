// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.Management.Storage;
using Azure.ResourceManager.Models;

namespace Azure.Management.Storage.Models
{
    internal static class StorageModelFactory
    {
        /// <summary> Initializes a new instance of BlobServiceItems. </summary>
        /// <param name="value"> List of blob services returned. </param>
        public static BlobServiceItems BlobServiceItems(IReadOnlyList<BlobServiceData> value = default)
        {
            return new BlobServiceItems(value);
        }

        /// <summary> Initializes a new instance of CorsRule. </summary>
        /// <param name="allowedOrigins"> Required if CorsRule element is present. A list of origin domains that will be allowed via CORS, or &quot;*&quot; to allow all domains. </param>
        /// <param name="allowedMethods"> Required if CorsRule element is present. A list of HTTP methods that are allowed to be executed by the origin. </param>
        /// <param name="maxAgeInSeconds"> Required if CorsRule element is present. The number of seconds that the client/browser should cache a preflight response. </param>
        /// <param name="exposedHeaders"> Required if CorsRule element is present. A list of response headers to expose to CORS clients. </param>
        /// <param name="allowedHeaders"> Required if CorsRule element is present. A list of headers allowed to be part of the cross-origin request. </param>
        public static CorsRule CorsRule(IList<string> allowedOrigins = default, IList<CorsRuleAllowedMethodsItem> allowedMethods = default, int maxAgeInSeconds = default, IList<string> exposedHeaders = default, IList<string> allowedHeaders = default)
        {
            return new CorsRule(allowedOrigins, allowedMethods, maxAgeInSeconds, exposedHeaders, allowedHeaders);
        }

        /// <summary> Initializes a new instance of DeleteRetentionPolicy. </summary>
        /// <param name="enabled"> Indicates whether DeleteRetentionPolicy is enabled. </param>
        /// <param name="days"> Indicates the number of days that the deleted item should be retained. The minimum specified value can be 1 and the maximum value can be 365. </param>
        public static DeleteRetentionPolicy DeleteRetentionPolicy(bool? enabled = default, int? days = default)
        {
            return new DeleteRetentionPolicy(enabled, days);
        }

        /// <summary> Initializes a new instance of ChangeFeed. </summary>
        /// <param name="enabled"> Indicates whether change feed event logging is enabled for the Blob service. </param>
        /// <param name="retentionInDays"> Indicates the duration of changeFeed retention in days. Minimum value is 1 day and maximum value is 146000 days (400 years). A null value indicates an infinite retention of the change feed. </param>
        public static ChangeFeed ChangeFeed(bool? enabled = default, int? retentionInDays = default)
        {
            return new ChangeFeed(enabled, retentionInDays);
        }

        /// <summary> Initializes a new instance of RestorePolicyProperties. </summary>
        /// <param name="enabled"> Blob restore is enabled if set to true. </param>
        /// <param name="days"> how long this blob can be restored. It should be great than zero and less than DeleteRetentionPolicy.days. </param>
        /// <param name="lastEnabledTime"> Deprecated in favor of minRestoreTime property. </param>
        /// <param name="minRestoreTime"> Returns the minimum date and time that the restore can be started. </param>
        public static RestorePolicyProperties RestorePolicyProperties(bool enabled = default, int? days = default, DateTimeOffset? lastEnabledTime = default, DateTimeOffset? minRestoreTime = default)
        {
            return new RestorePolicyProperties(enabled, days, lastEnabledTime, minRestoreTime);
        }

        /// <summary> Initializes a new instance of LastAccessTimeTrackingPolicy. </summary>
        /// <param name="enable"> When set to true last access time based tracking is enabled. </param>
        /// <param name="name"> Name of the policy. The valid value is AccessTimeTracking. This field is currently read only. </param>
        /// <param name="trackingGranularityInDays"> The field specifies blob object tracking granularity in days, typically how often the blob object should be tracked.This field is currently read only with value as 1. </param>
        /// <param name="blobType"> An array of predefined supported blob types. Only blockBlob is the supported value. This field is currently read only. </param>
        public static LastAccessTimeTrackingPolicy LastAccessTimeTrackingPolicy(bool enable = default, Name? name = default, int? trackingGranularityInDays = default, IList<string> blobType = default)
        {
            return new LastAccessTimeTrackingPolicy(enable, name, trackingGranularityInDays, blobType);
        }

        /// <summary> Initializes a new instance of StorageSku. </summary>
        /// <param name="name"> The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType. </param>
        /// <param name="tier"> The SKU tier. This is based on the SKU name. </param>
        public static StorageSku StorageSku(StorageSkuName name = default, StorageSkuTier? tier = default)
        {
            return new StorageSku(name, tier);
        }

        /// <summary> Initializes a new instance of ListContainerItems. </summary>
        /// <param name="value"> List of blobs containers returned. </param>
        /// <param name="nextLink"> Request URL that can be used to query next page of containers. Returned when total number of requested containers exceed maximum page size. </param>
        public static ListContainerItems ListContainerItems(IReadOnlyList<BlobContainerData> value = default, string nextLink = default)
        {
            return new ListContainerItems(value, nextLink);
        }

        /// <summary> Initializes a new instance of ImmutabilityPolicyProperties. </summary>
        /// <param name="etag"> ImmutabilityPolicy Etag. </param>
        /// <param name="updateHistory"> The ImmutabilityPolicy update history of the blob container. </param>
        /// <param name="immutabilityPeriodSinceCreationInDays"> The immutability period for the blobs in the container since the policy creation, in days. </param>
        /// <param name="state"> The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked. </param>
        /// <param name="allowProtectedAppendWrites"> This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API. </param>
        /// <param name="allowProtectedAppendWritesAll"> This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to both &apos;Append and Bock Blobs&apos; while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API. The &apos;allowProtectedAppendWrites&apos; and &apos;allowProtectedAppendWritesAll&apos; properties are mutually exclusive. </param>
        public static ImmutabilityPolicyProperties ImmutabilityPolicyProperties(string etag = default, IReadOnlyList<UpdateHistoryProperty> updateHistory = default, int? immutabilityPeriodSinceCreationInDays = default, ImmutabilityPolicyState? state = default, bool? allowProtectedAppendWrites = default, bool? allowProtectedAppendWritesAll = default)
        {
            return new ImmutabilityPolicyProperties(etag, updateHistory, immutabilityPeriodSinceCreationInDays, state, allowProtectedAppendWrites, allowProtectedAppendWritesAll);
        }

        /// <summary> Initializes a new instance of UpdateHistoryProperty. </summary>
        /// <param name="update"> The ImmutabilityPolicy update type of a blob container, possible values include: put, lock and extend. </param>
        /// <param name="immutabilityPeriodSinceCreationInDays"> The immutability period for the blobs in the container since the policy creation, in days. </param>
        /// <param name="timestamp"> Returns the date and time the ImmutabilityPolicy was updated. </param>
        /// <param name="objectIdentifier"> Returns the Object ID of the user who updated the ImmutabilityPolicy. </param>
        /// <param name="tenantId"> Returns the Tenant ID that issued the token for the user who updated the ImmutabilityPolicy. </param>
        /// <param name="upn"> Returns the User Principal Name of the user who updated the ImmutabilityPolicy. </param>
        /// <param name="allowProtectedAppendWrites"> This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API. </param>
        /// <param name="allowProtectedAppendWritesAll"> This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to both &apos;Append and Bock Blobs&apos; while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API. The &apos;allowProtectedAppendWrites&apos; and &apos;allowProtectedAppendWritesAll&apos; properties are mutually exclusive. </param>
        public static UpdateHistoryProperty UpdateHistoryProperty(ImmutabilityPolicyUpdateType? update = default, int? immutabilityPeriodSinceCreationInDays = default, DateTimeOffset? timestamp = default, string objectIdentifier = default, string tenantId = default, string upn = default, bool? allowProtectedAppendWrites = default, bool? allowProtectedAppendWritesAll = default)
        {
            return new UpdateHistoryProperty(update, immutabilityPeriodSinceCreationInDays, timestamp, objectIdentifier, tenantId, upn, allowProtectedAppendWrites, allowProtectedAppendWritesAll);
        }

        /// <summary> Initializes a new instance of LegalHoldProperties. </summary>
        /// <param name="hasLegalHold"> The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account. </param>
        /// <param name="tags"> The list of LegalHold tags of a blob container. </param>
        /// <param name="protectedAppendWritesHistory"> Protected append blob writes history. </param>
        public static LegalHoldProperties LegalHoldProperties(bool? hasLegalHold = default, IReadOnlyList<TagProperty> tags = default, ProtectedAppendWritesHistory protectedAppendWritesHistory = default)
        {
            return new LegalHoldProperties(hasLegalHold, tags, protectedAppendWritesHistory);
        }

        /// <summary> Initializes a new instance of TagProperty. </summary>
        /// <param name="tag"> The tag value. </param>
        /// <param name="timestamp"> Returns the date and time the tag was added. </param>
        /// <param name="objectIdentifier"> Returns the Object ID of the user who added the tag. </param>
        /// <param name="tenantId"> Returns the Tenant ID that issued the token for the user who added the tag. </param>
        /// <param name="upn"> Returns the User Principal Name of the user who added the tag. </param>
        public static TagProperty TagProperty(string tag = default, DateTimeOffset? timestamp = default, string objectIdentifier = default, string tenantId = default, string upn = default)
        {
            return new TagProperty(tag, timestamp, objectIdentifier, tenantId, upn);
        }

        /// <summary> Initializes a new instance of ProtectedAppendWritesHistory. </summary>
        /// <param name="allowProtectedAppendWritesAll"> When enabled, new blocks can be written to both &apos;Append and Bock Blobs&apos; while maintaining legal hold protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. </param>
        /// <param name="timestamp"> Returns the date and time the tag was added. </param>
        public static ProtectedAppendWritesHistory ProtectedAppendWritesHistory(bool? allowProtectedAppendWritesAll = default, DateTimeOffset? timestamp = default)
        {
            return new ProtectedAppendWritesHistory(allowProtectedAppendWritesAll, timestamp);
        }

        /// <summary> Initializes a new instance of ImmutableStorageWithVersioning. </summary>
        /// <param name="enabled"> This is an immutable property, when set to true it enables object level immutability at the container level. </param>
        /// <param name="timeStamp"> Returns the date and time the object level immutability was enabled. </param>
        /// <param name="migrationState"> This property denotes the container level immutability to object level immutability migration state. </param>
        public static ImmutableStorageWithVersioning ImmutableStorageWithVersioning(bool? enabled = default, DateTimeOffset? timeStamp = default, MigrationState? migrationState = default)
        {
            return new ImmutableStorageWithVersioning(enabled, timeStamp, migrationState);
        }

        /// <summary> Initializes a new instance of AzureEntityResource. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="etag"> Resource Etag. </param>
        public static AzureEntityResource AzureEntityResource(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, ResourceManager.Models.SystemData systemData = default, string etag = default)
        {
            return new AzureEntityResource(id, name, resourceType, systemData, etag);
        }

        /// <summary> Initializes a new instance of LegalHold. </summary>
        /// <param name="hasLegalHold"> The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account. </param>
        /// <param name="tags"> Each tag should be 3 to 23 alphanumeric characters and is normalized to lower case at SRP. </param>
        /// <param name="allowProtectedAppendWritesAll"> When enabled, new blocks can be written to both &apos;Append and Bock Blobs&apos; while maintaining legal hold protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. </param>
        public static LegalHold LegalHold(bool? hasLegalHold = default, IList<string> tags = default, bool? allowProtectedAppendWritesAll = default)
        {
            return new LegalHold(hasLegalHold, tags, allowProtectedAppendWritesAll);
        }

        /// <summary> Initializes a new instance of LeaseContainerResponse. </summary>
        /// <param name="leaseId"> Returned unique lease ID that must be included with any request to delete the container, or to renew, change, or release the lease. </param>
        /// <param name="leaseTimeSeconds"> Approximate time remaining in the lease period, in seconds. </param>
        public static LeaseContainerResponse LeaseContainerResponse(string leaseId = default, string leaseTimeSeconds = default)
        {
            return new LeaseContainerResponse(leaseId, leaseTimeSeconds);
        }

        /// <summary> Initializes a new instance of CloudError. </summary>
        /// <param name="error"> An error response from the Storage service. </param>
        public static CloudError CloudError(CloudErrorBody error = default)
        {
            return new CloudError(error);
        }

        /// <summary> Initializes a new instance of CloudErrorBody. </summary>
        /// <param name="code"> An identifier for the error. Codes are invariant and are intended to be consumed programmatically. </param>
        /// <param name="message"> A message describing the error, intended to be suitable for display in a user interface. </param>
        /// <param name="target"> The target of the particular error. For example, the name of the property in error. </param>
        /// <param name="details"> A list of additional details about the error. </param>
        public static CloudErrorBody CloudErrorBody(string code = default, string message = default, string target = default, IReadOnlyList<CloudErrorBody> details = default)
        {
            return new CloudErrorBody(code, message, target, details);
        }

        /// <summary> Initializes a new instance of SmbSetting. </summary>
        /// <param name="multichannel"> Multichannel setting. Applies to Premium FileStorage only. </param>
        /// <param name="versions"> SMB protocol versions supported by server. Valid values are SMB2.1, SMB3.0, SMB3.1.1. Should be passed as a string with delimiter &apos;;&apos;. </param>
        /// <param name="authenticationMethods"> SMB authentication methods supported by server. Valid values are NTLMv2, Kerberos. Should be passed as a string with delimiter &apos;;&apos;. </param>
        /// <param name="kerberosTicketEncryption"> Kerberos ticket encryption supported by server. Valid values are RC4-HMAC, AES-256. Should be passed as a string with delimiter &apos;;&apos;. </param>
        /// <param name="channelEncryption"> SMB channel encryption supported by server. Valid values are AES-128-CCM, AES-128-GCM, AES-256-GCM. Should be passed as a string with delimiter &apos;;&apos;. </param>
        public static SmbSetting SmbSetting(Multichannel multichannel = default, string versions = default, string authenticationMethods = default, string kerberosTicketEncryption = default, string channelEncryption = default)
        {
            return new SmbSetting(multichannel, versions, authenticationMethods, kerberosTicketEncryption, channelEncryption);
        }

        /// <summary> Initializes a new instance of CloudErrorAutoGenerated. </summary>
        /// <param name="error"> An error response from the Storage service. </param>
        public static CloudErrorAutoGenerated CloudErrorAutoGenerated(CloudErrorBodyAutoGenerated error = default)
        {
            return new CloudErrorAutoGenerated(error);
        }

        /// <summary> Initializes a new instance of CloudErrorBodyAutoGenerated. </summary>
        /// <param name="code"> An identifier for the error. Codes are invariant and are intended to be consumed programmatically. </param>
        /// <param name="message"> A message describing the error, intended to be suitable for display in a user interface. </param>
        /// <param name="target"> The target of the particular error. For example, the name of the property in error. </param>
        /// <param name="details"> A list of additional details about the error. </param>
        public static CloudErrorBodyAutoGenerated CloudErrorBodyAutoGenerated(string code = default, string message = default, string target = default, IReadOnlyList<CloudErrorBodyAutoGenerated> details = default)
        {
            return new CloudErrorBodyAutoGenerated(code, message, target, details);
        }

        /// <summary> Initializes a new instance of FileShareItems. </summary>
        /// <param name="value"> List of file shares returned. </param>
        /// <param name="nextLink"> Request URL that can be used to query next page of shares. Returned when total number of requested shares exceed maximum page size. </param>
        public static FileShareItems FileShareItems(IReadOnlyList<FileShareData> value = default, string nextLink = default)
        {
            return new FileShareItems(value, nextLink);
        }

        /// <summary> Initializes a new instance of SignedIdentifier. </summary>
        /// <param name="id"> An unique identifier of the stored access policy. </param>
        /// <param name="accessPolicy"> Access policy. </param>
        public static SignedIdentifier SignedIdentifier(string id = default, AccessPolicy accessPolicy = default)
        {
            return new SignedIdentifier(id, accessPolicy);
        }

        /// <summary> Initializes a new instance of AccessPolicy. </summary>
        /// <param name="startTime"> Start time of the access policy. </param>
        /// <param name="expiryTime"> Expiry time of the access policy. </param>
        /// <param name="permission"> List of abbreviated permissions. </param>
        public static AccessPolicy AccessPolicy(DateTimeOffset? startTime = default, DateTimeOffset? expiryTime = default, string permission = default)
        {
            return new AccessPolicy(startTime, expiryTime, permission);
        }

        /// <summary> Initializes a new instance of LeaseShareResponse. </summary>
        /// <param name="leaseId"> Returned unique lease ID that must be included with any request to delete the share, or to renew, change, or release the lease. </param>
        /// <param name="leaseTimeSeconds"> Approximate time remaining in the lease period, in seconds. </param>
        public static LeaseShareResponse LeaseShareResponse(string leaseId = default, string leaseTimeSeconds = default)
        {
            return new LeaseShareResponse(leaseId, leaseTimeSeconds);
        }

        /// <summary> Initializes a new instance of StorageSkuListResult. </summary>
        /// <param name="value"> Get the list result of storage SKUs and their properties. </param>
        public static StorageSkuListResult StorageSkuListResult(IReadOnlyList<StorageSkuInformation> value = default)
        {
            return new StorageSkuListResult(value);
        }

        /// <summary> Initializes a new instance of StorageSkuInformation. </summary>
        /// <param name="name"> The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType. </param>
        /// <param name="tier"> The SKU tier. This is based on the SKU name. </param>
        /// <param name="resourceType"> The type of the resource, usually it is &apos;storageAccounts&apos;. </param>
        /// <param name="kind"> Indicates the type of storage account. </param>
        /// <param name="locations"> The set of locations that the SKU is available. This will be supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). </param>
        /// <param name="capabilities"> The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc. </param>
        /// <param name="restrictions"> The restrictions because of which SKU cannot be used. This is empty if there are no restrictions. </param>
        public static StorageSkuInformation StorageSkuInformation(StorageSkuName name = default, StorageSkuTier? tier = default, string resourceType = default, StorageKind? kind = default, IReadOnlyList<string> locations = default, IReadOnlyList<SKUCapability> capabilities = default, IReadOnlyList<Restriction> restrictions = default)
        {
            return new StorageSkuInformation(name, tier, resourceType, kind, locations, capabilities, restrictions);
        }

        /// <summary> Initializes a new instance of SKUCapability. </summary>
        /// <param name="name"> The name of capability, The capability information in the specified SKU, including file encryption, network ACLs, change notification, etc. </param>
        /// <param name="value"> A string value to indicate states of given capability. Possibly &apos;true&apos; or &apos;false&apos;. </param>
        public static SKUCapability SKUCapability(string name = default, string value = default)
        {
            return new SKUCapability(name, value);
        }

        /// <summary> Initializes a new instance of Restriction. </summary>
        /// <param name="restrictionType"> The type of restrictions. As of now only possible value for this is location. </param>
        /// <param name="values"> The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted. </param>
        /// <param name="reasonCode"> The reason for the restriction. As of now this can be &quot;QuotaId&quot; or &quot;NotAvailableForSubscription&quot;. Quota Id is set when the SKU has requiredQuotas parameter as the subscription does not belong to that quota. The &quot;NotAvailableForSubscription&quot; is related to capacity at DC. </param>
        public static Restriction Restriction(string restrictionType = default, IReadOnlyList<string> values = default, ReasonCode? reasonCode = default)
        {
            return new Restriction(restrictionType, values, reasonCode);
        }

        /// <summary> Initializes a new instance of CheckNameAvailabilityResult. </summary>
        /// <param name="nameAvailable"> Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or is invalid and cannot be used. </param>
        /// <param name="reason"> Gets the reason that a storage account name could not be used. The Reason element is only returned if NameAvailable is false. </param>
        /// <param name="message"> Gets an error message explaining the Reason value in more detail. </param>
        public static CheckNameAvailabilityResult CheckNameAvailabilityResult(bool? nameAvailable = default, Reason? reason = default, string message = default)
        {
            return new CheckNameAvailabilityResult(nameAvailable, reason, message);
        }

        /// <summary> Initializes a new instance of ExtendedLocation. </summary>
        /// <param name="name"> The name of the extended location. </param>
        /// <param name="extendedLocationType"> The type of the extended location. </param>
        public static ExtendedLocation ExtendedLocation(string name = default, ExtendedLocationTypes? extendedLocationType = default)
        {
            return new ExtendedLocation(name, extendedLocationType);
        }

        /// <summary> Initializes a new instance of SasPolicy. </summary>
        /// <param name="sasExpirationPeriod"> The SAS expiration period, DD.HH:MM:SS. </param>
        /// <param name="expirationAction"> The SAS expiration action. Can only be Log. </param>
        public static SasPolicy SasPolicy(string sasExpirationPeriod = default, ExpirationAction expirationAction = default)
        {
            return new SasPolicy(sasExpirationPeriod, expirationAction);
        }

        /// <summary> Initializes a new instance of CustomDomain. </summary>
        /// <param name="name"> Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source. </param>
        /// <param name="useSubDomainName"> Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates. </param>
        public static CustomDomain CustomDomain(string name = default, bool? useSubDomainName = default)
        {
            return new CustomDomain(name, useSubDomainName);
        }

        /// <summary> Initializes a new instance of Encryption. </summary>
        /// <param name="services"> List of services which support encryption. </param>
        /// <param name="keySource"> The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. </param>
        /// <param name="requireInfrastructureEncryption"> A boolean indicating whether or not the service applies a secondary layer of encryption with platform managed keys for data at rest. </param>
        /// <param name="keyVaultProperties"> Properties provided by key vault. </param>
        /// <param name="encryptionIdentity"> The identity to be used with service-side encryption at rest. </param>
        public static Encryption Encryption(EncryptionServices services = default, KeySource keySource = default, bool? requireInfrastructureEncryption = default, KeyVaultProperties keyVaultProperties = default, EncryptionIdentity encryptionIdentity = default)
        {
            return new Encryption(services, keySource, requireInfrastructureEncryption, keyVaultProperties, encryptionIdentity);
        }

        /// <summary> Initializes a new instance of EncryptionServices. </summary>
        /// <param name="blob"> The encryption function of the blob storage service. </param>
        /// <param name="file"> The encryption function of the file storage service. </param>
        /// <param name="table"> The encryption function of the table storage service. </param>
        /// <param name="queue"> The encryption function of the queue storage service. </param>
        public static EncryptionServices EncryptionServices(EncryptionService blob = default, EncryptionService file = default, EncryptionService table = default, EncryptionService queue = default)
        {
            return new EncryptionServices(blob, file, table, queue);
        }

        /// <summary> Initializes a new instance of EncryptionService. </summary>
        /// <param name="enabled"> A boolean indicating whether or not the service encrypts the data as it is stored. </param>
        /// <param name="lastEnabledTime"> Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate. </param>
        /// <param name="keyType"> Encryption key type to be used for the encryption service. &apos;Account&apos; key type implies that an account-scoped encryption key will be used. &apos;Service&apos; key type implies that a default service key is used. </param>
        public static EncryptionService EncryptionService(bool? enabled = default, DateTimeOffset? lastEnabledTime = default, KeyType? keyType = default)
        {
            return new EncryptionService(enabled, lastEnabledTime, keyType);
        }

        /// <summary> Initializes a new instance of KeyVaultProperties. </summary>
        /// <param name="keyName"> The name of KeyVault key. </param>
        /// <param name="keyVersion"> The version of KeyVault key. </param>
        /// <param name="keyVaultUri"> The Uri of KeyVault. </param>
        /// <param name="currentVersionedKeyIdentifier"> The object identifier of the current versioned Key Vault Key in use. </param>
        /// <param name="lastKeyRotationTimestamp"> Timestamp of last rotation of the Key Vault Key. </param>
        public static KeyVaultProperties KeyVaultProperties(string keyName = default, string keyVersion = default, Uri keyVaultUri = default, string currentVersionedKeyIdentifier = default, DateTimeOffset? lastKeyRotationTimestamp = default)
        {
            return new KeyVaultProperties(keyName, keyVersion, keyVaultUri, currentVersionedKeyIdentifier, lastKeyRotationTimestamp);
        }

        /// <summary> Initializes a new instance of NetworkRuleSet. </summary>
        /// <param name="bypass"> Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, &quot;Logging, Metrics&quot;), or None to bypass none of those traffics. </param>
        /// <param name="resourceAccessRules"> Sets the resource access rules. </param>
        /// <param name="virtualNetworkRules"> Sets the virtual network rules. </param>
        /// <param name="ipRules"> Sets the IP ACL rules. </param>
        /// <param name="defaultAction"> Specifies the default action of allow or deny when no other rules match. </param>
        public static NetworkRuleSet NetworkRuleSet(Bypass? bypass = default, IList<ResourceAccessRule> resourceAccessRules = default, IList<VirtualNetworkRule> virtualNetworkRules = default, IList<IPRule> ipRules = default, DefaultAction defaultAction = default)
        {
            return new NetworkRuleSet(bypass, resourceAccessRules, virtualNetworkRules, ipRules, defaultAction);
        }

        /// <summary> Initializes a new instance of ResourceAccessRule. </summary>
        /// <param name="tenantId"> Tenant Id. </param>
        /// <param name="resourceId"> Resource Id. </param>
        public static ResourceAccessRule ResourceAccessRule(string tenantId = default, string resourceId = default)
        {
            return new ResourceAccessRule(tenantId, resourceId);
        }

        /// <summary> Initializes a new instance of VirtualNetworkRule. </summary>
        /// <param name="virtualNetworkResourceId"> Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}. </param>
        /// <param name="action"> The action of virtual network rule. </param>
        /// <param name="state"> Gets the state of virtual network rule. </param>
        public static VirtualNetworkRule VirtualNetworkRule(string virtualNetworkResourceId = default, string action = default, State? state = default)
        {
            return new VirtualNetworkRule(virtualNetworkResourceId, action, state);
        }

        /// <summary> Initializes a new instance of IPRule. </summary>
        /// <param name="ipAddressOrRange"> Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed. </param>
        /// <param name="action"> The action of IP ACL rule. </param>
        public static IPRule IPRule(string ipAddressOrRange = default, string action = default)
        {
            return new IPRule(ipAddressOrRange, action);
        }

        /// <summary> Initializes a new instance of AzureFilesIdentityBasedAuthentication. </summary>
        /// <param name="directoryServiceOptions"> Indicates the directory service used. </param>
        /// <param name="activeDirectoryProperties"> Required if choose AD. </param>
        /// <param name="defaultSharePermission"> Default share permission for users using Kerberos authentication if RBAC role is not assigned. </param>
        public static AzureFilesIdentityBasedAuthentication AzureFilesIdentityBasedAuthentication(DirectoryServiceOptions directoryServiceOptions = default, ActiveDirectoryProperties activeDirectoryProperties = default, DefaultSharePermission? defaultSharePermission = default)
        {
            return new AzureFilesIdentityBasedAuthentication(directoryServiceOptions, activeDirectoryProperties, defaultSharePermission);
        }

        /// <summary> Initializes a new instance of ActiveDirectoryProperties. </summary>
        /// <param name="domainName"> Specifies the primary domain that the AD DNS server is authoritative for. </param>
        /// <param name="netBiosDomainName"> Specifies the NetBIOS domain name. </param>
        /// <param name="forestName"> Specifies the Active Directory forest to get. </param>
        /// <param name="domainGuid"> Specifies the domain GUID. </param>
        /// <param name="domainSid"> Specifies the security identifier (SID). </param>
        /// <param name="azureStorageSid"> Specifies the security identifier (SID) for Azure Storage. </param>
        public static ActiveDirectoryProperties ActiveDirectoryProperties(string domainName = default, string netBiosDomainName = default, string forestName = default, string domainGuid = default, string domainSid = default, string azureStorageSid = default)
        {
            return new ActiveDirectoryProperties(domainName, netBiosDomainName, forestName, domainGuid, domainSid, azureStorageSid);
        }

        /// <summary> Initializes a new instance of RoutingPreference. </summary>
        /// <param name="routingChoice"> Routing Choice defines the kind of network routing opted by the user. </param>
        /// <param name="publishMicrosoftEndpoints"> A boolean flag which indicates whether microsoft routing storage endpoints are to be published. </param>
        /// <param name="publishInternetEndpoints"> A boolean flag which indicates whether internet routing storage endpoints are to be published. </param>
        public static RoutingPreference RoutingPreference(RoutingChoice? routingChoice = default, bool? publishMicrosoftEndpoints = default, bool? publishInternetEndpoints = default)
        {
            return new RoutingPreference(routingChoice, publishMicrosoftEndpoints, publishInternetEndpoints);
        }

        /// <summary> Initializes a new instance of ImmutableStorageAccount. </summary>
        /// <param name="enabled"> A boolean flag which enables account-level immutability. All the containers under such an account have object-level immutability enabled by default. </param>
        /// <param name="immutabilityPolicy"> Specifies the default account-level immutability policy which is inherited and applied to objects that do not possess an explicit immutability policy at the object level. The object-level immutability policy has higher precedence than the container-level immutability policy, which has a higher precedence than the account-level immutability policy. </param>
        public static ImmutableStorageAccount ImmutableStorageAccount(bool? enabled = default, AccountImmutabilityPolicyProperties immutabilityPolicy = default)
        {
            return new ImmutableStorageAccount(enabled, immutabilityPolicy);
        }

        /// <summary> Initializes a new instance of AccountImmutabilityPolicyProperties. </summary>
        /// <param name="immutabilityPeriodSinceCreationInDays"> The immutability period for the blobs in the container since the policy creation, in days. </param>
        /// <param name="state"> The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which cannot be reverted. </param>
        /// <param name="allowProtectedAppendWrites"> This property can only be changed for disabled and unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. </param>
        public static AccountImmutabilityPolicyProperties AccountImmutabilityPolicyProperties(int? immutabilityPeriodSinceCreationInDays = default, AccountImmutabilityPolicyState? state = default, bool? allowProtectedAppendWrites = default)
        {
            return new AccountImmutabilityPolicyProperties(immutabilityPeriodSinceCreationInDays, state, allowProtectedAppendWrites);
        }

        /// <summary> Initializes a new instance of Endpoints. </summary>
        /// <param name="blob"> Gets the blob endpoint. </param>
        /// <param name="queue"> Gets the queue endpoint. </param>
        /// <param name="table"> Gets the table endpoint. </param>
        /// <param name="file"> Gets the file endpoint. </param>
        /// <param name="web"> Gets the web endpoint. </param>
        /// <param name="dfs"> Gets the dfs endpoint. </param>
        /// <param name="microsoftEndpoints"> Gets the microsoft routing storage endpoints. </param>
        /// <param name="internetEndpoints"> Gets the internet routing storage endpoints. </param>
        public static Endpoints Endpoints(string blob = default, string queue = default, string table = default, string file = default, string web = default, string dfs = default, StorageAccountMicrosoftEndpoints microsoftEndpoints = default, StorageAccountInternetEndpoints internetEndpoints = default)
        {
            return new Endpoints(blob, queue, table, file, web, dfs, microsoftEndpoints, internetEndpoints);
        }

        /// <summary> Initializes a new instance of StorageAccountMicrosoftEndpoints. </summary>
        /// <param name="blob"> Gets the blob endpoint. </param>
        /// <param name="queue"> Gets the queue endpoint. </param>
        /// <param name="table"> Gets the table endpoint. </param>
        /// <param name="file"> Gets the file endpoint. </param>
        /// <param name="web"> Gets the web endpoint. </param>
        /// <param name="dfs"> Gets the dfs endpoint. </param>
        public static StorageAccountMicrosoftEndpoints StorageAccountMicrosoftEndpoints(string blob = default, string queue = default, string table = default, string file = default, string web = default, string dfs = default)
        {
            return new StorageAccountMicrosoftEndpoints(blob, queue, table, file, web, dfs);
        }

        /// <summary> Initializes a new instance of StorageAccountInternetEndpoints. </summary>
        /// <param name="blob"> Gets the blob endpoint. </param>
        /// <param name="file"> Gets the file endpoint. </param>
        /// <param name="web"> Gets the web endpoint. </param>
        /// <param name="dfs"> Gets the dfs endpoint. </param>
        public static StorageAccountInternetEndpoints StorageAccountInternetEndpoints(string blob = default, string file = default, string web = default, string dfs = default)
        {
            return new StorageAccountInternetEndpoints(blob, file, web, dfs);
        }

        /// <summary> Initializes a new instance of KeyCreationTime. </summary>
        /// <param name="key1"></param>
        /// <param name="key2"></param>
        public static KeyCreationTime KeyCreationTime(DateTimeOffset? key1 = default, DateTimeOffset? key2 = default)
        {
            return new KeyCreationTime(key1, key2);
        }

        /// <summary> Initializes a new instance of GeoReplicationStats. </summary>
        /// <param name="status"> The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable. </param>
        /// <param name="lastSyncTime"> All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap. </param>
        /// <param name="canFailover"> A boolean flag which indicates whether or not account failover is supported for the account. </param>
        public static GeoReplicationStats GeoReplicationStats(GeoReplicationStatus? status = default, DateTimeOffset? lastSyncTime = default, bool? canFailover = default)
        {
            return new GeoReplicationStats(status, lastSyncTime, canFailover);
        }

        /// <summary> Initializes a new instance of PrivateLinkServiceConnectionState. </summary>
        /// <param name="status"> Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service. </param>
        /// <param name="description"> The reason for approval/rejection of the connection. </param>
        /// <param name="actionRequired"> A message indicating if changes on the service provider require any updates on the consumer. </param>
        public static PrivateLinkServiceConnectionState PrivateLinkServiceConnectionState(PrivateEndpointServiceConnectionStatus? status = default, string description = default, string actionRequired = default)
        {
            return new PrivateLinkServiceConnectionState(status, description, actionRequired);
        }

        /// <summary> Initializes a new instance of BlobRestoreStatus. </summary>
        /// <param name="status"> The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. - Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed. </param>
        /// <param name="failureReason"> Failure reason when blob restore is failed. </param>
        /// <param name="restoreId"> Id for tracking blob restore request. </param>
        /// <param name="parameters"> Blob restore request parameters. </param>
        public static BlobRestoreStatus BlobRestoreStatus(BlobRestoreProgressStatus? status = default, string failureReason = default, string restoreId = default, BlobRestoreParameters parameters = default)
        {
            return new BlobRestoreStatus(status, failureReason, restoreId, parameters);
        }

        /// <summary> Initializes a new instance of BlobRestoreParameters. </summary>
        /// <param name="timeToRestore"> Restore blob to the specified time. </param>
        /// <param name="blobRanges"> Blob ranges to restore. </param>
        public static BlobRestoreParameters BlobRestoreParameters(DateTimeOffset timeToRestore = default, IList<BlobRestoreRange> blobRanges = default)
        {
            return new BlobRestoreParameters(timeToRestore, blobRanges);
        }

        /// <summary> Initializes a new instance of BlobRestoreRange. </summary>
        /// <param name="startRange"> Blob start range. This is inclusive. Empty means account start. </param>
        /// <param name="endRange"> Blob end range. This is exclusive. Empty means account end. </param>
        public static BlobRestoreRange BlobRestoreRange(string startRange = default, string endRange = default)
        {
            return new BlobRestoreRange(startRange, endRange);
        }

        /// <summary> Initializes a new instance of DeletedAccountListResult. </summary>
        /// <param name="value"> Gets the list of deleted accounts and their properties. </param>
        /// <param name="nextLink"> Request URL that can be used to query next page of deleted accounts. Returned when total number of requested deleted accounts exceed maximum page size. </param>
        public static DeletedAccountListResult DeletedAccountListResult(IReadOnlyList<DeletedAccountData> value = default, string nextLink = default)
        {
            return new DeletedAccountListResult(value, nextLink);
        }

        /// <summary> Initializes a new instance of ErrorResponse. </summary>
        /// <param name="error"> Azure Storage Resource Provider error response body. </param>
        public static ErrorResponse ErrorResponse(ErrorResponseBody error = default)
        {
            return new ErrorResponse(error);
        }

        /// <summary> Initializes a new instance of ErrorResponseBody. </summary>
        /// <param name="code"> An identifier for the error. Codes are invariant and are intended to be consumed programmatically. </param>
        /// <param name="message"> A message describing the error, intended to be suitable for display in a user interface. </param>
        public static ErrorResponseBody ErrorResponseBody(string code = default, string message = default)
        {
            return new ErrorResponseBody(code, message);
        }

        /// <summary> Initializes a new instance of StorageAccountListResult. </summary>
        /// <param name="value"> Gets the list of storage accounts and their properties. </param>
        /// <param name="nextLink"> Request URL that can be used to query next page of storage accounts. Returned when total number of requested storage accounts exceed maximum page size. </param>
        public static StorageAccountListResult StorageAccountListResult(IReadOnlyList<StorageAccountData> value = default, string nextLink = default)
        {
            return new StorageAccountListResult(value, nextLink);
        }

        /// <summary> Initializes a new instance of StorageAccountListKeysResult. </summary>
        /// <param name="keys"> Gets the list of storage account keys and their properties for the specified storage account. </param>
        public static StorageAccountListKeysResult StorageAccountListKeysResult(IReadOnlyList<StorageAccountKey> keys = default)
        {
            return new StorageAccountListKeysResult(keys);
        }

        /// <summary> Initializes a new instance of StorageAccountKey. </summary>
        /// <param name="keyName"> Name of the key. </param>
        /// <param name="value"> Base 64-encoded value of the key. </param>
        /// <param name="permissions"> Permissions for the key -- read-only or full permissions. </param>
        /// <param name="creationTime"> Creation time of the key, in round trip date format. </param>
        public static StorageAccountKey StorageAccountKey(string keyName = default, string value = default, KeyPermission? permissions = default, DateTimeOffset? creationTime = default)
        {
            return new StorageAccountKey(keyName, value, permissions, creationTime);
        }

        /// <summary> Initializes a new instance of UsageListResult. </summary>
        /// <param name="value"> Gets or sets the list of Storage Resource Usages. </param>
        public static UsageListResult UsageListResult(IReadOnlyList<StorageUsage> value = default)
        {
            return new UsageListResult(value);
        }

        /// <summary> Initializes a new instance of StorageUsage. </summary>
        /// <param name="unit"> Gets the unit of measurement. </param>
        /// <param name="currentValue"> Gets the current count of the allocated resources in the subscription. </param>
        /// <param name="limit"> Gets the maximum count of the resources that can be allocated in the subscription. </param>
        /// <param name="name"> Gets the name of the type of usage. </param>
        public static StorageUsage StorageUsage(UsageUnit? unit = default, int? currentValue = default, int? limit = default, UsageName name = default)
        {
            return new StorageUsage(unit, currentValue, limit, name);
        }

        /// <summary> Initializes a new instance of UsageName. </summary>
        /// <param name="value"> Gets a string describing the resource name. </param>
        /// <param name="localizedValue"> Gets a localized string describing the resource name. </param>
        public static UsageName UsageName(string value = default, string localizedValue = default)
        {
            return new UsageName(value, localizedValue);
        }

        /// <summary> Initializes a new instance of ListAccountSasResponse. </summary>
        /// <param name="accountSasToken"> List SAS credentials of storage account. </param>
        public static ListAccountSasResponse ListAccountSasResponse(string accountSasToken = default)
        {
            return new ListAccountSasResponse(accountSasToken);
        }

        /// <summary> Initializes a new instance of ListServiceSasResponse. </summary>
        /// <param name="serviceSasToken"> List service SAS credentials of specific resource. </param>
        public static ListServiceSasResponse ListServiceSasResponse(string serviceSasToken = default)
        {
            return new ListServiceSasResponse(serviceSasToken);
        }

        /// <summary> Initializes a new instance of ManagementPolicyRule. </summary>
        /// <param name="enabled"> Rule is enabled if set to true. </param>
        /// <param name="name"> A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy. </param>
        /// <param name="ruleType"> The valid value is Lifecycle. </param>
        /// <param name="definition"> An object that defines the Lifecycle rule. </param>
        public static ManagementPolicyRule ManagementPolicyRule(bool? enabled = default, string name = default, RuleType ruleType = default, ManagementPolicyDefinition definition = default)
        {
            return new ManagementPolicyRule(enabled, name, ruleType, definition);
        }

        /// <summary> Initializes a new instance of ManagementPolicyDefinition. </summary>
        /// <param name="actions"> An object that defines the action set. </param>
        /// <param name="filters"> An object that defines the filter set. </param>
        public static ManagementPolicyDefinition ManagementPolicyDefinition(ManagementPolicyAction actions = default, ManagementPolicyFilter filters = default)
        {
            return new ManagementPolicyDefinition(actions, filters);
        }

        /// <summary> Initializes a new instance of ManagementPolicyAction. </summary>
        /// <param name="baseBlob"> The management policy action for base blob. </param>
        /// <param name="snapshot"> The management policy action for snapshot. </param>
        /// <param name="version"> The management policy action for version. </param>
        public static ManagementPolicyAction ManagementPolicyAction(ManagementPolicyBaseBlob baseBlob = default, ManagementPolicySnapShot snapshot = default, ManagementPolicyVersion version = default)
        {
            return new ManagementPolicyAction(baseBlob, snapshot, version);
        }

        /// <summary> Initializes a new instance of ManagementPolicyBaseBlob. </summary>
        /// <param name="tierToCool"> The function to tier blobs to cool storage. Support blobs currently at Hot tier. </param>
        /// <param name="tierToArchive"> The function to tier blobs to archive storage. Support blobs currently at Hot or Cool tier. </param>
        /// <param name="delete"> The function to delete the blob. </param>
        /// <param name="enableAutoTierToHotFromCool"> This property enables auto tiering of a blob from cool to hot on a blob access. This property requires tierToCool.daysAfterLastAccessTimeGreaterThan. </param>
        public static ManagementPolicyBaseBlob ManagementPolicyBaseBlob(DateAfterModification tierToCool = default, DateAfterModification tierToArchive = default, DateAfterModification delete = default, bool? enableAutoTierToHotFromCool = default)
        {
            return new ManagementPolicyBaseBlob(tierToCool, tierToArchive, delete, enableAutoTierToHotFromCool);
        }

        /// <summary> Initializes a new instance of DateAfterModification. </summary>
        /// <param name="daysAfterModificationGreaterThan"> Value indicating the age in days after last modification. </param>
        /// <param name="daysAfterLastAccessTimeGreaterThan"> Value indicating the age in days after last blob access. This property can only be used in conjunction with last access time tracking policy. </param>
        public static DateAfterModification DateAfterModification(float? daysAfterModificationGreaterThan = default, float? daysAfterLastAccessTimeGreaterThan = default)
        {
            return new DateAfterModification(daysAfterModificationGreaterThan, daysAfterLastAccessTimeGreaterThan);
        }

        /// <summary> Initializes a new instance of ManagementPolicySnapShot. </summary>
        /// <param name="tierToCool"> The function to tier blob snapshot to cool storage. Support blob snapshot currently at Hot tier. </param>
        /// <param name="tierToArchive"> The function to tier blob snapshot to archive storage. Support blob snapshot currently at Hot or Cool tier. </param>
        /// <param name="delete"> The function to delete the blob snapshot. </param>
        public static ManagementPolicySnapShot ManagementPolicySnapShot(DateAfterCreation tierToCool = default, DateAfterCreation tierToArchive = default, DateAfterCreation delete = default)
        {
            return new ManagementPolicySnapShot(tierToCool, tierToArchive, delete);
        }

        /// <summary> Initializes a new instance of ManagementPolicyVersion. </summary>
        /// <param name="tierToCool"> The function to tier blob version to cool storage. Support blob version currently at Hot tier. </param>
        /// <param name="tierToArchive"> The function to tier blob version to archive storage. Support blob version currently at Hot or Cool tier. </param>
        /// <param name="delete"> The function to delete the blob version. </param>
        public static ManagementPolicyVersion ManagementPolicyVersion(DateAfterCreation tierToCool = default, DateAfterCreation tierToArchive = default, DateAfterCreation delete = default)
        {
            return new ManagementPolicyVersion(tierToCool, tierToArchive, delete);
        }

        /// <summary> Initializes a new instance of ManagementPolicyFilter. </summary>
        /// <param name="prefixMatch"> An array of strings for prefixes to be match. </param>
        /// <param name="blobTypes"> An array of predefined enum values. Currently blockBlob supports all tiering and delete actions. Only delete actions are supported for appendBlob. </param>
        /// <param name="blobIndexMatch"> An array of blob index tag based filters, there can be at most 10 tag filters. </param>
        public static ManagementPolicyFilter ManagementPolicyFilter(IList<string> prefixMatch = default, IList<string> blobTypes = default, IList<TagFilter> blobIndexMatch = default)
        {
            return new ManagementPolicyFilter(prefixMatch, blobTypes, blobIndexMatch);
        }

        /// <summary> Initializes a new instance of TagFilter. </summary>
        /// <param name="name"> This is the filter tag name, it can have 1 - 128 characters. </param>
        /// <param name="op"> This is the comparison operator which is used for object comparison and filtering. Only == (equality operator) is currently supported. </param>
        /// <param name="value"> This is the filter tag value field used for tag based filtering, it can have 0 - 256 characters. </param>
        public static TagFilter TagFilter(string name = default, string op = default, string value = default)
        {
            return new TagFilter(name, op, value);
        }

        /// <summary> Initializes a new instance of BlobInventoryPolicySchema. </summary>
        /// <param name="enabled"> Policy is enabled if set to true. </param>
        /// <param name="inventoryRuleType"> The valid value is Inventory. </param>
        /// <param name="rules"> The storage account blob inventory policy rules. The rule is applied when it is enabled. </param>
        public static BlobInventoryPolicySchema BlobInventoryPolicySchema(bool enabled = default, InventoryRuleType inventoryRuleType = default, IList<BlobInventoryPolicyRule> rules = default)
        {
            return new BlobInventoryPolicySchema(enabled, inventoryRuleType, rules);
        }

        /// <summary> Initializes a new instance of BlobInventoryPolicyRule. </summary>
        /// <param name="enabled"> Rule is enabled when set to true. </param>
        /// <param name="name"> A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy. </param>
        /// <param name="destination"> Container name where blob inventory files are stored. Must be pre-created. </param>
        /// <param name="definition"> An object that defines the blob inventory policy rule. </param>
        public static BlobInventoryPolicyRule BlobInventoryPolicyRule(bool enabled = default, string name = default, string destination = default, BlobInventoryPolicyDefinition definition = default)
        {
            return new BlobInventoryPolicyRule(enabled, name, destination, definition);
        }

        /// <summary> Initializes a new instance of BlobInventoryPolicyDefinition. </summary>
        /// <param name="filters"> An object that defines the filter set. </param>
        /// <param name="format"> This is a required field, it specifies the format for the inventory files. </param>
        /// <param name="schedule"> This is a required field. This field is used to schedule an inventory formation. </param>
        /// <param name="objectType"> This is a required field. This field specifies the scope of the inventory created either at the blob or container level. </param>
        /// <param name="schemaFields"> This is a required field. This field specifies the fields and properties of the object to be included in the inventory. The Schema field value &apos;Name&apos; is always required. The valid values for this field for the &apos;Blob&apos; definition.objectType include &apos;Name, Creation-Time, Last-Modified, Content-Length, Content-MD5, BlobType, AccessTier, AccessTierChangeTime, AccessTierInferred, Tags, Expiry-Time, hdi_isfolder, Owner, Group, Permissions, Acl, Snapshot, VersionId, IsCurrentVersion, Metadata, LastAccessTime&apos;. The valid values for &apos;Container&apos; definition.objectType include &apos;Name, Last-Modified, Metadata, LeaseStatus, LeaseState, LeaseDuration, PublicAccess, HasImmutabilityPolicy, HasLegalHold&apos;. Schema field values &apos;Expiry-Time, hdi_isfolder, Owner, Group, Permissions, Acl&apos; are valid only for Hns enabled accounts.&apos;Tags&apos; field is only valid for non Hns accounts. </param>
        public static BlobInventoryPolicyDefinition BlobInventoryPolicyDefinition(BlobInventoryPolicyFilter filters = default, Format format = default, Schedule schedule = default, ObjectType objectType = default, IList<string> schemaFields = default)
        {
            return new BlobInventoryPolicyDefinition(filters, format, schedule, objectType, schemaFields);
        }

        /// <summary> Initializes a new instance of BlobInventoryPolicyFilter. </summary>
        /// <param name="prefixMatch"> An array of strings for blob prefixes to be matched. </param>
        /// <param name="blobTypes"> An array of predefined enum values. Valid values include blockBlob, appendBlob, pageBlob. Hns accounts does not support pageBlobs. This field is required when definition.objectType property is set to &apos;Blob&apos;. </param>
        /// <param name="includeBlobVersions"> Includes blob versions in blob inventory when value is set to true. The definition.schemaFields values &apos;VersionId and IsCurrentVersion&apos; are required if this property is set to true, else they must be excluded. </param>
        /// <param name="includeSnapshots"> Includes blob snapshots in blob inventory when value is set to true. The definition.schemaFields value &apos;Snapshot&apos; is required if this property is set to true, else it must be excluded. </param>
        public static BlobInventoryPolicyFilter BlobInventoryPolicyFilter(IList<string> prefixMatch = default, IList<string> blobTypes = default, bool? includeBlobVersions = default, bool? includeSnapshots = default)
        {
            return new BlobInventoryPolicyFilter(prefixMatch, blobTypes, includeBlobVersions, includeSnapshots);
        }

        /// <summary> Initializes a new instance of ListBlobInventoryPolicy. </summary>
        /// <param name="value"> List of blob inventory policies. </param>
        public static ListBlobInventoryPolicy ListBlobInventoryPolicy(IReadOnlyList<BlobInventoryPolicyData> value = default)
        {
            return new ListBlobInventoryPolicy(value);
        }

        /// <summary> Initializes a new instance of PrivateEndpointConnectionListResult. </summary>
        /// <param name="value"> Array of private endpoint connections. </param>
        public static PrivateEndpointConnectionListResult PrivateEndpointConnectionListResult(IReadOnlyList<PrivateEndpointConnectionData> value = default)
        {
            return new PrivateEndpointConnectionListResult(value);
        }

        /// <summary> Initializes a new instance of PrivateLinkResource. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="groupId"> The private link resource group id. </param>
        /// <param name="requiredMembers"> The private link resource required member names. </param>
        /// <param name="requiredZoneNames"> The private link resource Private link DNS zone name. </param>
        public static PrivateLinkResource PrivateLinkResource(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, ResourceManager.Models.SystemData systemData = default, string groupId = default, IReadOnlyList<string> requiredMembers = default, IList<string> requiredZoneNames = default)
        {
            return new PrivateLinkResource(id, name, resourceType, systemData, groupId, requiredMembers, requiredZoneNames);
        }

        /// <summary> Initializes a new instance of ObjectReplicationPolicies. </summary>
        /// <param name="value"> The replication policy between two storage accounts. </param>
        public static ObjectReplicationPolicies ObjectReplicationPolicies(IReadOnlyList<ObjectReplicationPolicyData> value = default)
        {
            return new ObjectReplicationPolicies(value);
        }

        /// <summary> Initializes a new instance of ObjectReplicationPolicyRule. </summary>
        /// <param name="ruleId"> Rule Id is auto-generated for each new rule on destination account. It is required for put policy on source account. </param>
        /// <param name="sourceContainer"> Required. Source container name. </param>
        /// <param name="destinationContainer"> Required. Destination container name. </param>
        /// <param name="filters"> Optional. An object that defines the filter set. </param>
        public static ObjectReplicationPolicyRule ObjectReplicationPolicyRule(string ruleId = default, string sourceContainer = default, string destinationContainer = default, ObjectReplicationPolicyFilter filters = default)
        {
            return new ObjectReplicationPolicyRule(ruleId, sourceContainer, destinationContainer, filters);
        }

        /// <summary> Initializes a new instance of ObjectReplicationPolicyFilter. </summary>
        /// <param name="prefixMatch"> Optional. Filters the results to replicate only blobs whose names begin with the specified prefix. </param>
        /// <param name="minCreationTime"> Blobs created after the time will be replicated to the destination. It must be in datetime format &apos;yyyy-MM-ddTHH:mm:ssZ&apos;. Example: 2020-02-19T16:05:00Z. </param>
        public static ObjectReplicationPolicyFilter ObjectReplicationPolicyFilter(IList<string> prefixMatch = default, string minCreationTime = default)
        {
            return new ObjectReplicationPolicyFilter(prefixMatch, minCreationTime);
        }

        /// <summary> Initializes a new instance of EncryptionScopeKeyVaultProperties. </summary>
        /// <param name="keyUri"> The object identifier for a key vault key object. When applied, the encryption scope will use the key referenced by the identifier to enable customer-managed key support on this encryption scope. </param>
        /// <param name="currentVersionedKeyIdentifier"> The object identifier of the current versioned Key Vault Key in use. </param>
        /// <param name="lastKeyRotationTimestamp"> Timestamp of last rotation of the Key Vault Key. </param>
        public static EncryptionScopeKeyVaultProperties EncryptionScopeKeyVaultProperties(Uri keyUri = default, string currentVersionedKeyIdentifier = default, DateTimeOffset? lastKeyRotationTimestamp = default)
        {
            return new EncryptionScopeKeyVaultProperties(keyUri, currentVersionedKeyIdentifier, lastKeyRotationTimestamp);
        }

        /// <summary> Initializes a new instance of EncryptionScopeListResult. </summary>
        /// <param name="value"> List of encryption scopes requested. </param>
        /// <param name="nextLink"> Request URL that can be used to query next page of encryption scopes. Returned when total number of requested encryption scopes exceeds the maximum page size. </param>
        public static EncryptionScopeListResult EncryptionScopeListResult(IReadOnlyList<EncryptionScopeData> value = default, string nextLink = default)
        {
            return new EncryptionScopeListResult(value, nextLink);
        }
    }
}
